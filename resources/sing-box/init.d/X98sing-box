#!/bin/sh

# Скрипт автозапуска sing-box
# Каскад: NDM -> sing-box
# Использует конфиг: /opt/etc/allow/sing-box/config.json

PREFIX="/opt"
BIN="$PREFIX/bin/sing-box"
CONF_DIR="$PREFIX/etc/allow/sing-box"
CONF_FILE="$CONF_DIR/config.json"
LOG_DIR="$PREFIX/var/log/allow/sing-box"
PIDFILE="$PREFIX/var/run/sing-box.pid"
ROUTE_TABLE=111
ROUTE_MARK=0x4
IFACE="sbtun0"

# Firewall / netfilter settings (iptables)
MARK_VALUE="${ROUTE_MARK}" # keep mark value consistent with routing
IPSET_NAME="bypass"

# If NDM runs this script from /opt/etc/ndm/netfilter.d, it can set env var "table"
# to the currently-applied iptables table (e.g. mangle/filter/nat).
ndm_table="${table:-}"

# Создаем директории для логов и PID файлов
PATH=/opt/bin:/opt/sbin:/sbin:/bin:/usr/sbin:/usr/bin
mkdir -p "$LOG_DIR"
mkdir -p "$(dirname "$PIDFILE")"

is_our_singbox_pid() {
    pid="$(echo "${1:-}" | tr -cd '0-9')"
    [ -n "${pid:-}" ] || return 1
    kill -0 "$pid" 2>/dev/null || return 1
    # Не считаем зомби живым процессом
    if [ -r "/proc/$pid/stat" ]; then
        state="$(awk '{print $3}' "/proc/$pid/stat" 2>/dev/null)"
        [ "$state" = "Z" ] && return 1
    fi

    if [ -r "/proc/$pid/cmdline" ]; then
        cmd="$(tr '\000' ' ' <"/proc/$pid/cmdline" 2>/dev/null | tr -d '\r\n')"
        [ -n "${cmd:-}" ] || return 1
        # Разрешаем как просто "sing-box", так и полный путь "/opt/bin/sing-box"
        case "$cmd" in
            sing-box\ *|*/sing-box\ *) ;;
            *) return 1 ;;
        esac
        case "$cmd" in
            *"-c $CONF_FILE"*|*"-c$CONF_FILE"*|*"--config $CONF_FILE"*|*"--config=$CONF_FILE"*) ;;
            *) return 1 ;;
        esac
        case "$cmd" in
            *" run "*|*" run"*) ;;
            *) return 1 ;;
        esac
        return 0
    fi

    for pat in \
        "sing-box.*run.*-c.*$CONF_FILE" \
        "sing-box.*-c.*$CONF_FILE.*run"
    do
        for p in $(pgrep -f "$pat" 2>/dev/null); do
            p="$(echo "$p" | tr -cd '0-9')"
            [ -n "${p:-}" ] || continue
            if [ "$p" = "$pid" ]; then
                return 0
            fi
        done
    done
    return 1
}

get_running_pids() {
    if [ -f "$PIDFILE" ]; then
        pid_file="$(cat "$PIDFILE" 2>/dev/null | tr -cd '0-9')"
        if [ -n "${pid_file:-}" ] && is_our_singbox_pid "$pid_file" 2>/dev/null; then
            echo "$pid_file"
            return 0
        fi
    fi

    found=0
    for p in $(pgrep -x sing-box 2>/dev/null); do
        p="$(echo "$p" | tr -cd '0-9')"
        [ -n "${p:-}" ] || continue
        if is_our_singbox_pid "$p" 2>/dev/null; then
            echo "$p"
            found=1
        fi
    done
    if [ "$found" -eq 1 ]; then
        return 0
    fi

    for pat in \
        "sing-box.*run.*-c.*$CONF_FILE" \
        "sing-box.*-c.*$CONF_FILE.*run"
    do
        for p in $(pgrep -f "$pat" 2>/dev/null); do
            p="$(echo "$p" | tr -cd '0-9')"
            [ -n "${p:-}" ] || continue
            if kill -0 "$p" 2>/dev/null; then
                echo "$p"
                found=1
            fi
        done
    done

    [ "$found" -eq 1 ] && return 0
    return 1
}

get_running_pid() {
    pid="$(get_running_pids 2>/dev/null | head -1 | tr -cd '0-9')"
    if [ -n "${pid:-}" ] && kill -0 "$pid" 2>/dev/null; then
        echo "$pid"
        return 0
    fi
    return 1
}

status_kv() {
    PIDS="$(get_running_pids 2>/dev/null || true)"
    PID_PRIMARY="$(echo "${PIDS:-}" | head -1 | tr -cd '0-9')"
    STATUS="notrunning"
    if [ -n "${PID_PRIMARY:-}" ] && kill -0 "$PID_PRIMARY" 2>/dev/null; then
        STATUS="running"
        echo "$PID_PRIMARY" >"$PIDFILE" 2>/dev/null || true
    fi
    echo "STATUS=$STATUS"
    echo "PID=$PID_PRIMARY"
    echo "CONF_FILE=$CONF_FILE"
    echo "PID_FILE=$PIDFILE"
    echo "LOG_DIR=$LOG_DIR"
}

# --- Firewall rules (mangle: mark/connmark) ---
mangle_del_rules() {
  # Remove in reverse order; tolerate missing rules.
  iptables -t mangle -D PREROUTING -m set --match-set "${IPSET_NAME}" dst -m set ! --match-set nonbypass dst -m mark --mark "${MARK_VALUE}/${MARK_VALUE}" -j CONNMARK --save-mark --nfmask 0xffffffff --ctmask 0xffffffff 2>/dev/null || true
  iptables -t mangle -D PREROUTING -m set --match-set "${IPSET_NAME}" dst -m set ! --match-set nonbypass dst -j CONNMARK --save-mark --nfmask 0xffffffff --ctmask 0xffffffff 2>/dev/null || true
  iptables -t mangle -D PREROUTING -m set --match-set "${IPSET_NAME}" dst -m set ! --match-set nonbypass dst -j MARK --set-xmark "${MARK_VALUE}/${MARK_VALUE}" 2>/dev/null || true
  iptables -t mangle -D PREROUTING -m set --match-set "${IPSET_NAME}" dst -m set ! --match-set nonbypass dst -j MARK --set-mark "${MARK_VALUE}" 2>/dev/null || true

  iptables -t mangle -D OUTPUT -m set --match-set "${IPSET_NAME}" dst -m set ! --match-set nonbypass dst -m mark --mark "${MARK_VALUE}/${MARK_VALUE}" -j CONNMARK --save-mark --nfmask 0xffffffff --ctmask 0xffffffff 2>/dev/null || true
  iptables -t mangle -D OUTPUT -m set --match-set "${IPSET_NAME}" dst -m set ! --match-set nonbypass dst -j CONNMARK --save-mark --nfmask 0xffffffff --ctmask 0xffffffff 2>/dev/null || true
  iptables -t mangle -D OUTPUT -m set --match-set "${IPSET_NAME}" dst -m set ! --match-set nonbypass dst -j MARK --set-xmark "${MARK_VALUE}/${MARK_VALUE}" 2>/dev/null || true
  iptables -t mangle -D OUTPUT -m set --match-set "${IPSET_NAME}" dst -m set ! --match-set nonbypass dst -j MARK --set-mark "${MARK_VALUE}" 2>/dev/null || true
}

mangle_add_rules() {
  # Both ipsets must exist: iptables set match requires existing sets.
  if ! ipset list "${IPSET_NAME}" >/dev/null 2>&1; then
    echo "[!] ipset '${IPSET_NAME}' not found, skipping mangle mark rules"
    return 1
  fi
  if ! ipset list nonbypass >/dev/null 2>&1; then
    echo "[!] ipset 'nonbypass' not found, skipping mangle mark rules (rules use ! --match-set nonbypass)"
    return 1
  fi

  # Append (not insert) so hotspot / system rules can run first.
  iptables -t mangle -A PREROUTING -m set --match-set "${IPSET_NAME}" dst -m set ! --match-set nonbypass dst -j MARK --set-xmark "${MARK_VALUE}/${MARK_VALUE}" 2>/dev/null || true
  iptables -t mangle -A PREROUTING -m set --match-set "${IPSET_NAME}" dst -m set ! --match-set nonbypass dst -m mark --mark "${MARK_VALUE}/${MARK_VALUE}" -j CONNMARK --save-mark --nfmask 0xffffffff --ctmask 0xffffffff 2>/dev/null || true
  iptables -t mangle -A OUTPUT -m set --match-set "${IPSET_NAME}" dst -m set ! --match-set nonbypass dst -j MARK --set-xmark "${MARK_VALUE}/${MARK_VALUE}" 2>/dev/null || true
  iptables -t mangle -A OUTPUT -m set --match-set "${IPSET_NAME}" dst -m set ! --match-set nonbypass dst -m mark --mark "${MARK_VALUE}/${MARK_VALUE}" -j CONNMARK --save-mark --nfmask 0xffffffff --ctmask 0xffffffff 2>/dev/null || true

  echo "[+] mangle mark rules added (${IPSET_NAME} !nonbypass -> ${MARK_VALUE})"
}

# --- Firewall rules (filter: allow sbtun0) ---
filter_del_rules() {
  iptables -D FORWARD -o "${IFACE}" -j ACCEPT 2>/dev/null || true
  iptables -D FORWARD -i "${IFACE}" -j ACCEPT 2>/dev/null || true
  iptables -D OUTPUT -o "${IFACE}" -j ACCEPT 2>/dev/null || true
  iptables -D INPUT -i "${IFACE}" -j ACCEPT 2>/dev/null || true
}

filter_add_rules() {
  iptables -I INPUT -i "${IFACE}" -j ACCEPT 2>/dev/null || true
  iptables -I OUTPUT -o "${IFACE}" -j ACCEPT 2>/dev/null || true
  iptables -I FORWARD -i "${IFACE}" -j ACCEPT 2>/dev/null || true
  iptables -I FORWARD -o "${IFACE}" -j ACCEPT 2>/dev/null || true
}

# Apply/unapply firewall depending on NDM table phase.
fw_should_apply_mangle() { [ -z "$ndm_table" ] || [ "$ndm_table" = "mangle" ]; }
fw_should_apply_filter() { [ -z "$ndm_table" ] || [ "$ndm_table" = "filter" ]; }

start_fw() {
  fw_should_apply_mangle && mangle_add_rules || true
  fw_should_apply_filter && filter_add_rules || true
}

stop_fw() {
  fw_should_apply_mangle && mangle_del_rules || true
  fw_should_apply_filter && filter_del_rules || true
}

restart_fw() {
  stop_fw
  start_fw
}

# Настройка маршрутизации для sbtun0
setup_routing() {
    # Ждем появления интерфейса
    retries=10
    while [ $retries -gt 0 ]; do
        if ip link show "$IFACE" >/dev/null 2>&1; then
            break
        fi
        sleep 1
        retries=$((retries - 1))
    done

    if ! ip link show "$IFACE" >/dev/null 2>&1; then
        echo "[!] Interface $IFACE not found, skipping routing setup"
        return 1
    fi

    # Добавляем правило маршрутизации (если еще нет)
    if ! ip rule show | grep -q "fwmark ${ROUTE_MARK}/${ROUTE_MARK}.*lookup ${ROUTE_TABLE}"; then
        ip rule add fwmark ${ROUTE_MARK}/${ROUTE_MARK} table ${ROUTE_TABLE} priority 99 2>/dev/null && \
            echo "[+] Added ip rule: fwmark ${ROUTE_MARK}/${ROUTE_MARK} prio 99 -> table ${ROUTE_TABLE}"
    fi

    # Добавляем маршрут по умолчанию (удаляем старый, если есть)
    ip route del table ${ROUTE_TABLE} default dev ${IFACE} 2>/dev/null || true
    ip route add table ${ROUTE_TABLE} default dev ${IFACE} 2>/dev/null && \
        echo "[+] Added route: table ${ROUTE_TABLE} default dev ${IFACE}"
}

cleanup_routing() {
    ip rule del fwmark ${ROUTE_MARK}/${ROUTE_MARK} table ${ROUTE_TABLE} priority 99 2>/dev/null || true
    ip rule del fwmark ${ROUTE_MARK}/${ROUTE_MARK} table ${ROUTE_TABLE} 2>/dev/null || true
    ip rule del fwmark ${ROUTE_MARK} table ${ROUTE_TABLE} 2>/dev/null || true
    ip route del table ${ROUTE_TABLE} default dev ${IFACE} 2>/dev/null || true
}

start() {
    echo "Запуск sing-box..."

    if [ ! -x "$BIN" ]; then
        echo "Ошибка: бинарник sing-box не найден: $BIN"
        return 1
    fi

    if [ ! -f "$CONF_FILE" ]; then
        echo "Ошибка: конфигурационный файл $CONF_FILE не найден"
        return 1
    fi

    if ! "$BIN" check -c "$CONF_FILE" >/dev/null 2>&1; then
        echo "Ошибка: конфиг не прошёл проверку (sing-box check), запуск отменён"
        return 1
    fi

    PIDS_RUNNING="$(get_running_pids 2>/dev/null || true)"
    PID_PRIMARY="$(echo "${PIDS_RUNNING:-}" | head -1 | tr -cd '0-9')"
    if [ -n "${PID_PRIMARY:-}" ] && kill -0 "$PID_PRIMARY" 2>/dev/null; then
        echo "sing-box уже запущен (PID: $PID_PRIMARY)"
        echo "$PID_PRIMARY" >"$PIDFILE" 2>/dev/null || true
        return 0
    fi

    "$BIN" run -c "$CONF_FILE" >/dev/null 2>>"$LOG_DIR/error.log" &
    echo $! >"$PIDFILE"
    sleep 2
    setup_routing
    restart_fw

    PIDS_RUNNING="$(get_running_pids 2>/dev/null || true)"
    PID_PRIMARY="$(echo "${PIDS_RUNNING:-}" | head -1 | tr -cd '0-9')"
    if [ -z "${PID_PRIMARY:-}" ] || ! kill -0 "$PID_PRIMARY" 2>/dev/null; then
        rm -f "$PIDFILE" 2>/dev/null || true
        echo "Ошибка: не удалось запустить sing-box"
        return 1
    fi
    sleep 1
    if ! kill -0 "$PID_PRIMARY" 2>/dev/null || ! is_our_singbox_pid "$PID_PRIMARY" 2>/dev/null; then
        rm -f "$PIDFILE" 2>/dev/null || true
        echo "Ошибка: sing-box завершился сразу после старта"
        return 1
    fi
    echo "sing-box запущен (PID: $PID_PRIMARY)"
    echo "$PID_PRIMARY" >"$PIDFILE" 2>/dev/null || true
    return 0
}

stop() {
    echo "Остановка sing-box..."
    stop_fw

    if [ -f "$PIDFILE" ]; then
        PID="$(cat "$PIDFILE" 2>/dev/null | tr -cd '0-9')"
        if [ -n "$PID" ] && is_our_singbox_pid "$PID" 2>/dev/null; then
            kill "$PID" 2>/dev/null
            sleep 1
            if kill -0 "$PID" 2>/dev/null; then
                kill -9 "$PID" 2>/dev/null
            fi
            echo "sing-box остановлен"
        else
            echo "sing-box не запущен (PID-файл устарел или указывает не на процесс Allow)"
        fi
        rm -f "$PIDFILE"
    else
        PIDS="$(get_running_pids 2>/dev/null || true)"
        if [ -n "${PIDS:-}" ]; then
            echo "$PIDS" | while read -r PID; do
                PID="$(echo "${PID:-}" | tr -cd '0-9')"
                [ -n "${PID:-}" ] || continue
                if kill -0 "$PID" 2>/dev/null; then
                    kill "$PID" 2>/dev/null
                    sleep 1
                    if kill -0 "$PID" 2>/dev/null; then
                        kill -9 "$PID" 2>/dev/null
                    fi
                    echo "sing-box остановлен (PID: $PID)"
                fi
            done
            rm -f "$PIDFILE" 2>/dev/null || true
        else
            echo "sing-box не запущен"
        fi
    fi

    EXTRA_PIDS=""
    if command -v pidof >/dev/null 2>&1; then
        EXTRA_PIDS="$(pidof sing-box 2>/dev/null || true)"
    else
        EXTRA_PIDS="$(ps w 2>/dev/null | awk '$0 ~ /\/opt\/bin\/sing-box/ && $0 ~ / run / {print $1}' 2>/dev/null || true)"
    fi
    for P in $EXTRA_PIDS; do
        [ -z "$P" ] && continue
        [ "$P" = "$$" ] && continue
        [ -n "${PID:-}" ] && [ "$P" = "$PID" ] && continue
        kill -9 "$P" 2>/dev/null || true
    done

    cleanup_routing
}

restart() {
    stop
    sleep 1
    start
}

status() {
    if [ "${2:-}" = "--kv" ] || [ "${2:-}" = "--machine" ] || [ "${1:-}" = "--kv" ] || [ "${1:-}" = "--machine" ]; then
        status_kv
        return 0
    fi

    PIDS="$(get_running_pids 2>/dev/null || true)"
    PID_PRIMARY="$(echo "${PIDS:-}" | head -1 | tr -cd '0-9')"
    if [ -n "${PID_PRIMARY:-}" ]; then
        echo "sing-box запущен (PID: $PID_PRIMARY)"
        echo "Конфиг: $CONF_FILE"
        return 0
    fi

    echo "sing-box не запущен"
    return 1
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart)
        restart
        ;;
    status)
        shift || true
        status "$@"
        ;;
    start-fw|start_fw)
        start_fw
        ;;
    stop-fw|stop_fw)
        stop_fw
        ;;
    restart-fw|restart_fw)
        restart_fw
        ;;
    *)
        echo "Использование: $0 {start|stop|restart|status|start-fw|stop-fw|restart-fw}"
        exit 1
        ;;
esac

exit 0
