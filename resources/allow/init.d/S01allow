#!/bin/sh

# Единый скрипт автозапуска для всех компонентов ALLOW
# Порядок запуска: определяется именами файлов в /opt/etc/allow/init.d (лексикографически).
# Логирование: /opt/var/log/allow/allowstart.log

PATH=/opt/bin:/opt/sbin:/sbin:/bin:/usr/sbin:/usr/bin

# Директория со скриптами компонентов
ALLOW_INITD_DIR="/opt/etc/allow/init.d"

# Лог файл
LOG_FILE="/opt/var/log/allow/allowstart.log"

# Создаем директории
mkdir -p /opt/var/log/allow /opt/var/run "$ALLOW_INITD_DIR" 2>/dev/null || true

# Функция логирования
log_msg() {
    local component="$1"
    local action="$2"
    local message="$3"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$component] [$action] $message" | tee -a "$LOG_FILE"
}

list_init_scripts() {
    # Возвращает список скриптов компонентов в /opt/etc/allow/init.d.
    # Политика: запускаем ТОЛЬКО файлы, начинающиеся с "S" и далее 2+ цифры (S01..., S97... и т.п.).
    # Отключение компонента: переименовать файл так, чтобы он не начинался с "S".
    if [ ! -d "$ALLOW_INITD_DIR" ]; then
        return 0
    fi

    for f in "$ALLOW_INITD_DIR"/S[0-9][0-9]*; do
        [ -f "$f" ] || continue
        echo "$f"
    done
}

sorted_scripts() {
    if command -v sort >/dev/null 2>&1; then
        list_init_scripts | sort
    else
        # Fallback: порядок оболочки (обычно лексикографический для glob).
        list_init_scripts
    fi
}

sorted_scripts_reverse() {
    if command -v sort >/dev/null 2>&1; then
        list_init_scripts | sort -r
    else
        # Без sort -r не гарантируем обратный порядок.
        list_init_scripts
    fi
}

run_script() {
    # $1: action, $2: script
    local action="$1"
    local script="$2"
    local name
    name="$(basename "$script")"

    if [ ! -f "$script" ]; then
        log_msg "$name" "WARN" "Скрипт не найден: $script"
        return 0
    fi

    log_msg "$name" "$action" "Выполняю: $script $action"
    # Важно: НЕ используем command substitution для вывода (иначе вывод буферизуется и кажется, что S01allow "висит").
    # Пишем вывод компонента напрямую в общий лог.
    sh "$script" "$action" >> "$LOG_FILE" 2>&1
    exit_code=$?

    if [ $exit_code -eq 0 ]; then
        log_msg "$name" "SUCCESS" "OK"
        return 0
    fi

    log_msg "$name" "ERROR" "Ошибка выполнения (код: $exit_code)"
    return $exit_code
}

# Функция запуска всех компонентов
start_all() {
    log_msg "SYSTEM" "START" "=== Запуск всех компонентов ALLOW ==="

    errors=0
    scripts="$(sorted_scripts 2>/dev/null || true)"
    if [ -z "${scripts:-}" ]; then
        log_msg "SYSTEM" "WARN" "В ${ALLOW_INITD_DIR} не найдено активных init-скриптов (S??*)"
        return 0
    fi

    for script in $scripts; do
        if ! run_script "start" "$script"; then
            errors=$((errors + 1))
        fi
    done

    if [ "$errors" -eq 0 ]; then
        log_msg "SYSTEM" "SUCCESS" "=== Все компоненты запущены успешно ==="
        return 0
    fi

    log_msg "SYSTEM" "WARN" "=== Запуск завершен с $errors ошибками ==="
    return 1
}

# Функция остановки всех компонентов (в обратном порядке)
stop_all() {
    log_msg "SYSTEM" "STOP" "=== Остановка всех компонентов ALLOW ==="

    scripts="$(sorted_scripts_reverse 2>/dev/null || true)"
    if [ -z "${scripts:-}" ]; then
        log_msg "SYSTEM" "WARN" "В ${ALLOW_INITD_DIR} не найдено активных init-скриптов (S??*)"
        return 0
    fi

    for script in $scripts; do
        # stop: best-effort, не прерываем общий stop из-за ошибок отдельных сервисов
        run_script "stop" "$script" >/dev/null 2>&1 || true
    done

    log_msg "SYSTEM" "SUCCESS" "=== Все компоненты остановлены ==="
}

# Функция перезапуска всех компонентов
restart_all() {
    log_msg "SYSTEM" "RESTART" "=== Перезапуск всех компонентов ALLOW ==="
    stop_all
    sleep 2
    start_all
}

# Функция статуса всех компонентов
status_all() {
    echo "=== Статус компонентов ALLOW ==="
    echo ""

    scripts="$(sorted_scripts 2>/dev/null || true)"
    if [ -z "${scripts:-}" ]; then
        echo "  (в ${ALLOW_INITD_DIR} нет активных init-скриптов S??*)"
        echo ""
        echo "Лог запуска: $LOG_FILE"
        return 0
    fi

    for script in $scripts; do
        name="$(basename "$script")"
        echo "  $name:"
        sh "$script" status 2>&1 || true
        echo ""
    done

    echo "Лог запуска: $LOG_FILE"
}

# Основная логика
case "$1" in
    start)
        start_all
        ;;
    stop)
        stop_all
        ;;
    restart)
        restart_all
        ;;
    status)
        status_all
        ;;
    *)
        echo "Использование: $0 {start|stop|restart|status}"
        echo ""
        echo "Активные init-скрипты (в порядке запуска):"
        scripts="$(sorted_scripts 2>/dev/null || true)"
        if [ -n "${scripts:-}" ]; then
            for script in $scripts; do
                echo "  - $(basename "$script")"
            done
        else
            echo "  (нет активных скриптов S??* в ${ALLOW_INITD_DIR})"
        fi
        echo ""
        echo "Логи: $LOG_FILE"
        exit 1
        ;;
esac

exit 0

